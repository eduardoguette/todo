var t=Object.defineProperty,r=Object.defineProperties,n=Object.getOwnPropertyDescriptors,e=Object.getOwnPropertySymbols,o=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,i=(r,n,e)=>n in r?t(r,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[n]=e,a=(t,r)=>{for(var n in r||(r={}))o.call(r,n)&&i(t,n,r[n]);if(e)for(var n of e(r))c.call(r,n)&&i(t,n,r[n]);return t},s=(t,e)=>r(t,n(e));import{createContext as u,useContext as l,useEffect as f,useState as d,useCallback as p,useRef as h,useReducer as g}from"react";const y=u(void 0),b=y.Provider,v=y.Consumer;function w(){const t=l(y);if(void 0===t)throw Error("No client has been specified using Provider.");return t}function m(t){const r=w();f((()=>{const{data:n}=r.auth.onAuthStateChange(t);return()=>{null==n||n.unsubscribe()}}),[])}y.displayName="SupabaseContext";const E={error:void 0,fetching:!1};function O(t={}){const r=w(),[n,e]=d(E);return[n,p((async(n,o)=>{e(s(a({},E),{fetching:!0}));const{error:c}=await r.auth.api.resetPasswordForEmail(n,null!=o?o:t.options),i={error:c};return e(s(a({},i),{fetching:!1})),i}),[r,t])]}const P={error:void 0,fetching:!1,session:void 0,user:void 0};function C(t={}){const r=w(),[n,e]=d(P);return[n,p((async(n,o)=>{e(s(a({},P),{fetching:!0}));const{error:c,session:i,user:u}=await r.auth.signIn(a({provider:t.provider},n),null!=o?o:t.options),l={error:c,session:i,user:u};return e(s(a({},l),{fetching:!1})),l}),[r,t])]}const I={error:void 0,fetching:!1};function S(){const t=w(),[r,n]=d(I);return[r,p((async()=>{n(s(a({},I),{fetching:!0}));const{error:r}=await t.auth.signOut(),e={error:r};return n(s(a({},e),{fetching:!1})),e}),[t])]}function T(t={}){const r=w(),[n,e]=d(P);return[n,p((async(n,o)=>{e(s(a({},P),{fetching:!0}));const{error:c,session:i,user:u}=await r.auth.signUp(n,null!=o?o:t.options),l={error:c,session:i,user:u};return e(s(a({},l),{fetching:!1})),l}),[r,t])]}const j={count:void 0,data:void 0,error:void 0,fetching:!1};function N(t,r={options:{}}){const n=w(),e=h(!1),[o,c]=d(j),i=p((async(o,i)=>{const u=null!=o?o:r.filter;if(void 0===u)throw Error("delete() should always be combined with `filter`");c(s(a({},j),{fetching:!0}));const l=n.from(t).delete(null!=i?i:r.options),{count:f,data:d,error:p}=await u(l),h={count:f,data:d,error:p};return e.current&&c(s(a({},h),{fetching:!1})),h}),[n]);return f((()=>(e.current=!0,()=>{e.current=!1})),[]),[o,i]}function U(t,r=[]){return p(t,r)}function x(t,r={options:{}}){const n=w(),e=h(!1),[o,c]=d(j),i=p((async(o,i)=>{c(s(a({},j),{fetching:!0}));const{count:u,data:l,error:f}=await n.from(t).insert(o,null!=i?i:r.options),d={count:u,data:l,error:f};return e.current&&c(s(a({},d),{fetching:!1})),d}),[n]);return f((()=>(e.current=!0,()=>{e.current=!1})),[]),[o,i]}function D(t,r={columns:"*",options:{}}){const n=w(),e=h(!1),[o,c]=d(s(a({},j),{stale:!1})),i=p((async()=>{if(r.pause)return null;c((t=>s(a({},j),{data:t.data,stale:!0,fetching:!0})));const o=n.from(t).select(r.columns,r.options),{count:i,data:u,error:l}=await(r.filter?r.filter(o):o),f={count:i,data:u,error:l};return e.current&&c(s(a({},f),{stale:!1,fetching:!1})),f}),[n,r,t]);return f((()=>(e.current=!0,i(),()=>{e.current=!1})),[null==r?void 0:r.filter]),[o,i]}function F(t,r={options:{}}){const n=w(),e=h(!1),[o,c]=d(j),i=p((async(o,i,u)=>{const l=null!=i?i:r.filter;if(void 0===l)throw Error("update() should always be combined with `filter`");c(s(a({},j),{fetching:!0}));const f=n.from(t).update(o,null!=u?u:r.options),{count:d,data:p,error:h}=await l(f),g={count:d,data:p,error:h};return e.current&&c(s(a({},g),{fetching:!1})),g}),[n]);return f((()=>(e.current=!0,()=>{e.current=!1})),[]),[o,i]}function R(t,r={options:{}}){const n=w(),e=h(!1),[o,c]=d(j),i=p((async(o,i,u)=>{const l=null!=u?u:r.filter;c(s(a({},j),{fetching:!0}));const f=n.from(t).upsert(o,null!=i?i:r.options),{count:d,data:p,error:h}=await(l?l(f):f),g={count:d,data:p,error:h};return e.current&&c(s(a({},g),{fetching:!1})),g}),[n]);return f((()=>(e.current=!0,()=>{e.current=!1})),[]),[o,i]}function A(t,r={event:"*",table:"*"}){const n=w();f((()=>{var e,o;const c=n.from(null!=(e=r.table)?e:"*").on(null!=(o=r.event)?o:"*",t).subscribe();return()=>{c.unsubscribe()}}),[])}function B(t,r,n=((t,r)=>t.id===r.id)){if("*"===t)throw Error("Must specify table or row. Cannot listen for all database changes.");const[e,o]=D(t,null==r?void 0:r.select),[c,i]=g(H(n),e);return A((t=>i({type:"SUBSCRIPTION",payload:t})),{table:t}),f((()=>{i({type:"FETCH",payload:e})}),[e]),[c,o]}const H=t=>(r,n)=>{var e;const o=r.data;switch(n.type){case"FETCH":return a(s(a({},r),{old:o}),n.payload);case"SUBSCRIPTION":switch(n.payload.eventType){case"DELETE":return s(a({},r),{data:null==(e=r.data)?void 0:e.filter((r=>!t(r,n.payload.old))),fetching:!1,old:o});case"INSERT":return s(a({},r),{data:[...null!=o?o:[],n.payload.new],fetching:!1,old:o});case"UPDATE":{const e=null!=o?o:[],c=e.findIndex((r=>t(r,n.payload.new)));return s(a({},r),{data:[...e.slice(0,c),n.payload.new,...e.slice(c+1)],fetching:!1,old:o})}}}};export{v as Consumer,y as Context,b as Provider,m as useAuthStateChange,w as useClient,N as useDelete,U as useFilter,x as useInsert,B as useRealtime,O as useResetPassword,D as useSelect,C as useSignIn,S as useSignOut,T as useSignUp,A as useSubscription,F as useUpdate,R as useUpsert};
