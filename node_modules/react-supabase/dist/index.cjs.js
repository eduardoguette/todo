"use strict";var e=Object.defineProperty,t=Object.defineProperties,r=Object.getOwnPropertyDescriptors,n=Object.getOwnPropertySymbols,o=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable,u=(t,r,n)=>r in t?e(t,r,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[r]=n,a=(e,t)=>{for(var r in t||(t={}))o.call(t,r)&&u(e,r,t[r]);if(n)for(var r of n(t))s.call(t,r)&&u(e,r,t[r]);return e},c=(e,n)=>t(e,r(n));Object.defineProperty(exports,"__esModule",{value:!0}),exports[Symbol.toStringTag]="Module";var i=require("react");const l=i.createContext(void 0),f=l.Provider,d=l.Consumer;function p(){const e=i.useContext(l);if(void 0===e)throw Error("No client has been specified using Provider.");return e}l.displayName="SupabaseContext";const h={error:void 0,fetching:!1};const b={error:void 0,fetching:!1,session:void 0,user:void 0};const g={error:void 0,fetching:!1};const y={count:void 0,data:void 0,error:void 0,fetching:!1};function v(e,t={columns:"*",options:{}}){const r=p(),n=i.useRef(!1),[o,s]=i.useState(c(a({},y),{stale:!1})),u=i.useCallback((async()=>{if(t.pause)return null;s((e=>c(a({},y),{data:e.data,stale:!0,fetching:!0})));const o=r.from(e).select(t.columns,t.options),{count:u,data:i,error:l}=await(t.filter?t.filter(o):o),f={count:u,data:i,error:l};return n.current&&s(c(a({},f),{stale:!1,fetching:!1})),f}),[r,t,e]);return i.useEffect((()=>(n.current=!0,u(),()=>{n.current=!1})),[null==t?void 0:t.filter]),[o,u]}function w(e,t={event:"*",table:"*"}){const r=p();i.useEffect((()=>{var n,o;const s=r.from(null!=(n=t.table)?n:"*").on(null!=(o=t.event)?o:"*",e).subscribe();return()=>{s.unsubscribe()}}),[])}const S=e=>(t,r)=>{var n;const o=t.data;switch(r.type){case"FETCH":return a(c(a({},t),{old:o}),r.payload);case"SUBSCRIPTION":switch(r.payload.eventType){case"DELETE":return c(a({},t),{data:null==(n=t.data)?void 0:n.filter((t=>!e(t,r.payload.old))),fetching:!1,old:o});case"INSERT":return c(a({},t),{data:[...null!=o?o:[],r.payload.new],fetching:!1,old:o});case"UPDATE":{const n=null!=o?o:[],s=n.findIndex((t=>e(t,r.payload.new)));return c(a({},t),{data:[...n.slice(0,s),r.payload.new,...n.slice(s+1)],fetching:!1,old:o})}}}};exports.Consumer=d,exports.Context=l,exports.Provider=f,exports.useAuthStateChange=function(e){const t=p();i.useEffect((()=>{const{data:r}=t.auth.onAuthStateChange(e);return()=>{null==r||r.unsubscribe()}}),[])},exports.useClient=p,exports.useDelete=function(e,t={options:{}}){const r=p(),n=i.useRef(!1),[o,s]=i.useState(y),u=i.useCallback((async(o,u)=>{const i=null!=o?o:t.filter;if(void 0===i)throw Error("delete() should always be combined with `filter`");s(c(a({},y),{fetching:!0}));const l=r.from(e).delete(null!=u?u:t.options),{count:f,data:d,error:p}=await i(l),h={count:f,data:d,error:p};return n.current&&s(c(a({},h),{fetching:!1})),h}),[r]);return i.useEffect((()=>(n.current=!0,()=>{n.current=!1})),[]),[o,u]},exports.useFilter=function(e,t=[]){return i.useCallback(e,t)},exports.useInsert=function(e,t={options:{}}){const r=p(),n=i.useRef(!1),[o,s]=i.useState(y),u=i.useCallback((async(o,u)=>{s(c(a({},y),{fetching:!0}));const{count:i,data:l,error:f}=await r.from(e).insert(o,null!=u?u:t.options),d={count:i,data:l,error:f};return n.current&&s(c(a({},d),{fetching:!1})),d}),[r]);return i.useEffect((()=>(n.current=!0,()=>{n.current=!1})),[]),[o,u]},exports.useRealtime=function(e,t,r=((e,t)=>e.id===t.id)){if("*"===e)throw Error("Must specify table or row. Cannot listen for all database changes.");const[n,o]=v(e,null==t?void 0:t.select),[s,u]=i.useReducer(S(r),n);return w((e=>u({type:"SUBSCRIPTION",payload:e})),{table:e}),i.useEffect((()=>{u({type:"FETCH",payload:n})}),[n]),[s,o]},exports.useResetPassword=function(e={}){const t=p(),[r,n]=i.useState(h);return[r,i.useCallback((async(r,o)=>{n(c(a({},h),{fetching:!0}));const{error:s}=await t.auth.api.resetPasswordForEmail(r,null!=o?o:e.options),u={error:s};return n(c(a({},u),{fetching:!1})),u}),[t,e])]},exports.useSelect=v,exports.useSignIn=function(e={}){const t=p(),[r,n]=i.useState(b);return[r,i.useCallback((async(r,o)=>{n(c(a({},b),{fetching:!0}));const{error:s,session:u,user:i}=await t.auth.signIn(a({provider:e.provider},r),null!=o?o:e.options),l={error:s,session:u,user:i};return n(c(a({},l),{fetching:!1})),l}),[t,e])]},exports.useSignOut=function(){const e=p(),[t,r]=i.useState(g);return[t,i.useCallback((async()=>{r(c(a({},g),{fetching:!0}));const{error:t}=await e.auth.signOut(),n={error:t};return r(c(a({},n),{fetching:!1})),n}),[e])]},exports.useSignUp=function(e={}){const t=p(),[r,n]=i.useState(b);return[r,i.useCallback((async(r,o)=>{n(c(a({},b),{fetching:!0}));const{error:s,session:u,user:i}=await t.auth.signUp(r,null!=o?o:e.options),l={error:s,session:u,user:i};return n(c(a({},l),{fetching:!1})),l}),[t,e])]},exports.useSubscription=w,exports.useUpdate=function(e,t={options:{}}){const r=p(),n=i.useRef(!1),[o,s]=i.useState(y),u=i.useCallback((async(o,u,i)=>{const l=null!=u?u:t.filter;if(void 0===l)throw Error("update() should always be combined with `filter`");s(c(a({},y),{fetching:!0}));const f=r.from(e).update(o,null!=i?i:t.options),{count:d,data:p,error:h}=await l(f),b={count:d,data:p,error:h};return n.current&&s(c(a({},b),{fetching:!1})),b}),[r]);return i.useEffect((()=>(n.current=!0,()=>{n.current=!1})),[]),[o,u]},exports.useUpsert=function(e,t={options:{}}){const r=p(),n=i.useRef(!1),[o,s]=i.useState(y),u=i.useCallback((async(o,u,i)=>{const l=null!=i?i:t.filter;s(c(a({},y),{fetching:!0}));const f=r.from(e).upsert(o,null!=u?u:t.options),{count:d,data:p,error:h}=await(l?l(f):f),b={count:d,data:p,error:h};return n.current&&s(c(a({},b),{fetching:!1})),b}),[r]);return i.useEffect((()=>(n.current=!0,()=>{n.current=!1})),[]),[o,u]};
