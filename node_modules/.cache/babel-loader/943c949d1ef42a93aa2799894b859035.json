{"ast":null,"code":"/**\n * Helpers to convert the change Payload into native JS types.\n */\n// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\nexport var PostgresTypes;\n\n(function (PostgresTypes) {\n  PostgresTypes[\"abstime\"] = \"abstime\";\n  PostgresTypes[\"bool\"] = \"bool\";\n  PostgresTypes[\"date\"] = \"date\";\n  PostgresTypes[\"daterange\"] = \"daterange\";\n  PostgresTypes[\"float4\"] = \"float4\";\n  PostgresTypes[\"float8\"] = \"float8\";\n  PostgresTypes[\"int2\"] = \"int2\";\n  PostgresTypes[\"int4\"] = \"int4\";\n  PostgresTypes[\"int4range\"] = \"int4range\";\n  PostgresTypes[\"int8\"] = \"int8\";\n  PostgresTypes[\"int8range\"] = \"int8range\";\n  PostgresTypes[\"json\"] = \"json\";\n  PostgresTypes[\"jsonb\"] = \"jsonb\";\n  PostgresTypes[\"money\"] = \"money\";\n  PostgresTypes[\"numeric\"] = \"numeric\";\n  PostgresTypes[\"oid\"] = \"oid\";\n  PostgresTypes[\"reltime\"] = \"reltime\";\n  PostgresTypes[\"time\"] = \"time\";\n  PostgresTypes[\"timestamp\"] = \"timestamp\";\n  PostgresTypes[\"timestamptz\"] = \"timestamptz\";\n  PostgresTypes[\"timetz\"] = \"timetz\";\n  PostgresTypes[\"tsrange\"] = \"tsrange\";\n  PostgresTypes[\"tstzrange\"] = \"tstzrange\";\n})(PostgresTypes || (PostgresTypes = {}));\n/**\n * Takes an array of columns and an object of string values then converts each string value\n * to its mapped type.\n *\n * @param {{name: String, type: String}[]} columns\n * @param {Object} records\n * @param {Object} options The map of various options that can be applied to the mapper\n * @param {Array} options.skipTypes The array of types that should not be converted\n *\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\n * //=>{ first_name: 'Paul', age: 33 }\n */\n\n\nexport const convertChangeData = (columns, records, options = {}) => {\n  let result = {};\n  let skipTypes = typeof options.skipTypes !== 'undefined' ? options.skipTypes : [];\n  Object.entries(records).map(([key, value]) => {\n    result[key] = convertColumn(key, columns, records, skipTypes);\n  });\n  return result;\n};\n/**\n * Converts the value of an individual column.\n *\n * @param {String} columnName The column that you want to convert\n * @param {{name: String, type: String}[]} columns All of the columns\n * @param {Object} records The map of string values\n * @param {Array} skipTypes An array of types that should not be converted\n * @return {object} Useless information\n *\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\n * //=> 33\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\n * //=> \"33\"\n */\n\nexport const convertColumn = (columnName, columns, records, skipTypes) => {\n  let column = columns.find(x => x.name == columnName);\n\n  if (!column || skipTypes.includes(column.type)) {\n    return noop(records[columnName]);\n  } else {\n    return convertCell(column.type, records[columnName]);\n  }\n};\n/**\n * If the value of the cell is `null`, returns null.\n * Otherwise converts the string value to the correct type.\n * @param {String} type A postgres column type\n * @param {String} stringValue The cell value\n *\n * @example convertCell('bool', 't')\n * //=> true\n * @example convertCell('int8', '10')\n * //=> 10\n * @example convertCell('_int4', '{1,2,3,4}')\n * //=> [1,2,3,4]\n */\n\nexport const convertCell = (type, stringValue) => {\n  try {\n    if (stringValue === null) return null; // if data type is an array\n\n    if (type.charAt(0) === '_') {\n      let arrayValue = type.slice(1, type.length);\n      return toArray(stringValue, arrayValue);\n    } // If not null, convert to correct type.\n\n\n    switch (type) {\n      case PostgresTypes.abstime:\n        return noop(stringValue);\n      // To allow users to cast it based on Timezone\n\n      case PostgresTypes.bool:\n        return toBoolean(stringValue);\n\n      case PostgresTypes.date:\n        return noop(stringValue);\n      // To allow users to cast it based on Timezone\n\n      case PostgresTypes.daterange:\n        return toDateRange(stringValue);\n\n      case PostgresTypes.float4:\n        return toFloat(stringValue);\n\n      case PostgresTypes.float8:\n        return toFloat(stringValue);\n\n      case PostgresTypes.int2:\n        return toInt(stringValue);\n\n      case PostgresTypes.int4:\n        return toInt(stringValue);\n\n      case PostgresTypes.int4range:\n        return toIntRange(stringValue);\n\n      case PostgresTypes.int8:\n        return toInt(stringValue);\n\n      case PostgresTypes.int8range:\n        return toIntRange(stringValue);\n\n      case PostgresTypes.json:\n        return toJson(stringValue);\n\n      case PostgresTypes.jsonb:\n        return toJson(stringValue);\n\n      case PostgresTypes.money:\n        return toFloat(stringValue);\n\n      case PostgresTypes.numeric:\n        return toFloat(stringValue);\n\n      case PostgresTypes.oid:\n        return toInt(stringValue);\n\n      case PostgresTypes.reltime:\n        return noop(stringValue);\n      // To allow users to cast it based on Timezone\n\n      case PostgresTypes.time:\n        return noop(stringValue);\n      // To allow users to cast it based on Timezone\n\n      case PostgresTypes.timestamp:\n        return toTimestampString(stringValue);\n      // Format to be consistent with PostgREST\n\n      case PostgresTypes.timestamptz:\n        return noop(stringValue);\n      // To allow users to cast it based on Timezone\n\n      case PostgresTypes.timetz:\n        return noop(stringValue);\n      // To allow users to cast it based on Timezone\n\n      case PostgresTypes.tsrange:\n        return toDateRange(stringValue);\n\n      case PostgresTypes.tstzrange:\n        return toDateRange(stringValue);\n\n      default:\n        // All the rest will be returned as strings\n        return noop(stringValue);\n    }\n  } catch (error) {\n    console.log(`Could not convert cell of type ${type} and value ${stringValue}`);\n    console.log(`This is the error: ${error}`);\n    return stringValue;\n  }\n};\n\nconst noop = stringValue => {\n  return stringValue;\n};\n\nexport const toBoolean = stringValue => {\n  switch (stringValue) {\n    case 't':\n      return true;\n\n    case 'f':\n      return false;\n\n    default:\n      return null;\n  }\n};\nexport const toDate = stringValue => {\n  return new Date(stringValue);\n};\nexport const toDateRange = stringValue => {\n  let arr = JSON.parse(stringValue);\n  return [new Date(arr[0]), new Date(arr[1])];\n};\nexport const toFloat = stringValue => {\n  return parseFloat(stringValue);\n};\nexport const toInt = stringValue => {\n  return parseInt(stringValue);\n};\nexport const toIntRange = stringValue => {\n  let arr = JSON.parse(stringValue);\n  return [parseInt(arr[0]), parseInt(arr[1])];\n};\nexport const toJson = stringValue => {\n  return JSON.parse(stringValue);\n};\n/**\n * Converts a Postgres Array into a native JS array\n *\n * @example toArray('{1,2,3,4}', 'int4')\n * //=> [1,2,3,4]\n * @example toArray('{}', 'int4')\n * //=> []\n */\n\nexport const toArray = (stringValue, type) => {\n  // this takes off the '{' & '}'\n  let stringEnriched = stringValue.slice(1, stringValue.length - 1); // converts the string into an array\n  // if string is empty (meaning the array was empty), an empty array will be immediately returned\n\n  let stringArray = stringEnriched.length > 0 ? stringEnriched.split(',') : [];\n  let array = stringArray.map(string => {\n    return convertCell(type, string);\n  });\n  return array;\n};\n/**\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\n * See https://github.com/supabase/supabase/issues/18\n *\n * @example toTimestampString('2019-09-10 00:00:00')\n * //=> '2019-09-10T00:00:00'\n */\n\nexport const toTimestampString = stringValue => {\n  return stringValue.replace(' ', 'T');\n};","map":{"version":3,"sources":["../../../src/lib/transformers.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * Helpers to convert the change Payload into native JS types.\n */\n// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\nexport var PostgresTypes;\n(function (PostgresTypes) {\n    PostgresTypes[\"abstime\"] = \"abstime\";\n    PostgresTypes[\"bool\"] = \"bool\";\n    PostgresTypes[\"date\"] = \"date\";\n    PostgresTypes[\"daterange\"] = \"daterange\";\n    PostgresTypes[\"float4\"] = \"float4\";\n    PostgresTypes[\"float8\"] = \"float8\";\n    PostgresTypes[\"int2\"] = \"int2\";\n    PostgresTypes[\"int4\"] = \"int4\";\n    PostgresTypes[\"int4range\"] = \"int4range\";\n    PostgresTypes[\"int8\"] = \"int8\";\n    PostgresTypes[\"int8range\"] = \"int8range\";\n    PostgresTypes[\"json\"] = \"json\";\n    PostgresTypes[\"jsonb\"] = \"jsonb\";\n    PostgresTypes[\"money\"] = \"money\";\n    PostgresTypes[\"numeric\"] = \"numeric\";\n    PostgresTypes[\"oid\"] = \"oid\";\n    PostgresTypes[\"reltime\"] = \"reltime\";\n    PostgresTypes[\"time\"] = \"time\";\n    PostgresTypes[\"timestamp\"] = \"timestamp\";\n    PostgresTypes[\"timestamptz\"] = \"timestamptz\";\n    PostgresTypes[\"timetz\"] = \"timetz\";\n    PostgresTypes[\"tsrange\"] = \"tsrange\";\n    PostgresTypes[\"tstzrange\"] = \"tstzrange\";\n})(PostgresTypes || (PostgresTypes = {}));\n/**\n * Takes an array of columns and an object of string values then converts each string value\n * to its mapped type.\n *\n * @param {{name: String, type: String}[]} columns\n * @param {Object} records\n * @param {Object} options The map of various options that can be applied to the mapper\n * @param {Array} options.skipTypes The array of types that should not be converted\n *\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\n * //=>{ first_name: 'Paul', age: 33 }\n */\nexport const convertChangeData = (columns, records, options = {}) => {\n    let result = {};\n    let skipTypes = typeof options.skipTypes !== 'undefined' ? options.skipTypes : [];\n    Object.entries(records).map(([key, value]) => {\n        result[key] = convertColumn(key, columns, records, skipTypes);\n    });\n    return result;\n};\n/**\n * Converts the value of an individual column.\n *\n * @param {String} columnName The column that you want to convert\n * @param {{name: String, type: String}[]} columns All of the columns\n * @param {Object} records The map of string values\n * @param {Array} skipTypes An array of types that should not be converted\n * @return {object} Useless information\n *\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\n * //=> 33\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\n * //=> \"33\"\n */\nexport const convertColumn = (columnName, columns, records, skipTypes) => {\n    let column = columns.find((x) => x.name == columnName);\n    if (!column || skipTypes.includes(column.type)) {\n        return noop(records[columnName]);\n    }\n    else {\n        return convertCell(column.type, records[columnName]);\n    }\n};\n/**\n * If the value of the cell is `null`, returns null.\n * Otherwise converts the string value to the correct type.\n * @param {String} type A postgres column type\n * @param {String} stringValue The cell value\n *\n * @example convertCell('bool', 't')\n * //=> true\n * @example convertCell('int8', '10')\n * //=> 10\n * @example convertCell('_int4', '{1,2,3,4}')\n * //=> [1,2,3,4]\n */\nexport const convertCell = (type, stringValue) => {\n    try {\n        if (stringValue === null)\n            return null;\n        // if data type is an array\n        if (type.charAt(0) === '_') {\n            let arrayValue = type.slice(1, type.length);\n            return toArray(stringValue, arrayValue);\n        }\n        // If not null, convert to correct type.\n        switch (type) {\n            case PostgresTypes.abstime:\n                return noop(stringValue); // To allow users to cast it based on Timezone\n            case PostgresTypes.bool:\n                return toBoolean(stringValue);\n            case PostgresTypes.date:\n                return noop(stringValue); // To allow users to cast it based on Timezone\n            case PostgresTypes.daterange:\n                return toDateRange(stringValue);\n            case PostgresTypes.float4:\n                return toFloat(stringValue);\n            case PostgresTypes.float8:\n                return toFloat(stringValue);\n            case PostgresTypes.int2:\n                return toInt(stringValue);\n            case PostgresTypes.int4:\n                return toInt(stringValue);\n            case PostgresTypes.int4range:\n                return toIntRange(stringValue);\n            case PostgresTypes.int8:\n                return toInt(stringValue);\n            case PostgresTypes.int8range:\n                return toIntRange(stringValue);\n            case PostgresTypes.json:\n                return toJson(stringValue);\n            case PostgresTypes.jsonb:\n                return toJson(stringValue);\n            case PostgresTypes.money:\n                return toFloat(stringValue);\n            case PostgresTypes.numeric:\n                return toFloat(stringValue);\n            case PostgresTypes.oid:\n                return toInt(stringValue);\n            case PostgresTypes.reltime:\n                return noop(stringValue); // To allow users to cast it based on Timezone\n            case PostgresTypes.time:\n                return noop(stringValue); // To allow users to cast it based on Timezone\n            case PostgresTypes.timestamp:\n                return toTimestampString(stringValue); // Format to be consistent with PostgREST\n            case PostgresTypes.timestamptz:\n                return noop(stringValue); // To allow users to cast it based on Timezone\n            case PostgresTypes.timetz:\n                return noop(stringValue); // To allow users to cast it based on Timezone\n            case PostgresTypes.tsrange:\n                return toDateRange(stringValue);\n            case PostgresTypes.tstzrange:\n                return toDateRange(stringValue);\n            default:\n                // All the rest will be returned as strings\n                return noop(stringValue);\n        }\n    }\n    catch (error) {\n        console.log(`Could not convert cell of type ${type} and value ${stringValue}`);\n        console.log(`This is the error: ${error}`);\n        return stringValue;\n    }\n};\nconst noop = (stringValue) => {\n    return stringValue;\n};\nexport const toBoolean = (stringValue) => {\n    switch (stringValue) {\n        case 't':\n            return true;\n        case 'f':\n            return false;\n        default:\n            return null;\n    }\n};\nexport const toDate = (stringValue) => {\n    return new Date(stringValue);\n};\nexport const toDateRange = (stringValue) => {\n    let arr = JSON.parse(stringValue);\n    return [new Date(arr[0]), new Date(arr[1])];\n};\nexport const toFloat = (stringValue) => {\n    return parseFloat(stringValue);\n};\nexport const toInt = (stringValue) => {\n    return parseInt(stringValue);\n};\nexport const toIntRange = (stringValue) => {\n    let arr = JSON.parse(stringValue);\n    return [parseInt(arr[0]), parseInt(arr[1])];\n};\nexport const toJson = (stringValue) => {\n    return JSON.parse(stringValue);\n};\n/**\n * Converts a Postgres Array into a native JS array\n *\n * @example toArray('{1,2,3,4}', 'int4')\n * //=> [1,2,3,4]\n * @example toArray('{}', 'int4')\n * //=> []\n */\nexport const toArray = (stringValue, type) => {\n    // this takes off the '{' & '}'\n    let stringEnriched = stringValue.slice(1, stringValue.length - 1);\n    // converts the string into an array\n    // if string is empty (meaning the array was empty), an empty array will be immediately returned\n    let stringArray = stringEnriched.length > 0 ? stringEnriched.split(',') : [];\n    let array = stringArray.map((string) => {\n        return convertCell(type, string);\n    });\n    return array;\n};\n/**\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\n * See https://github.com/supabase/supabase/issues/18\n *\n * @example toTimestampString('2019-09-10 00:00:00')\n * //=> '2019-09-10T00:00:00'\n */\nexport const toTimestampString = (stringValue) => {\n    return stringValue.replace(' ', 'T');\n};\n//# sourceMappingURL=transformers.js.map"]},"metadata":{},"sourceType":"module"}